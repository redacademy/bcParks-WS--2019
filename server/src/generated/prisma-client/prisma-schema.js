module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDays {
  count: Int!
}

type AggregateFeature {
  count: Int!
}

type AggregateGeometry {
  count: Int!
}

type AggregateGeoPoint {
  count: Int!
}

type AggregateGoal {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregateNorthEast {
  count: Int!
}

type AggregatePlusCode {
  count: Int!
}

type AggregateProgress {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateSouthWest {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateViewport {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Days {
  id: ID!
  title: String!
}

type DaysConnection {
  pageInfo: PageInfo!
  edges: [DaysEdge]!
  aggregate: AggregateDays!
}

input DaysCreateInput {
  id: ID
  title: String!
}

input DaysCreateOneInput {
  create: DaysCreateInput
  connect: DaysWhereUniqueInput
}

type DaysEdge {
  node: Days!
  cursor: String!
}

enum DaysOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type DaysPreviousValues {
  id: ID!
  title: String!
}

type DaysSubscriptionPayload {
  mutation: MutationType!
  node: Days
  updatedFields: [String!]
  previousValues: DaysPreviousValues
}

input DaysSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DaysWhereInput
  AND: [DaysSubscriptionWhereInput!]
  OR: [DaysSubscriptionWhereInput!]
  NOT: [DaysSubscriptionWhereInput!]
}

input DaysUpdateDataInput {
  title: String
}

input DaysUpdateInput {
  title: String
}

input DaysUpdateManyMutationInput {
  title: String
}

input DaysUpdateOneRequiredInput {
  create: DaysCreateInput
  update: DaysUpdateDataInput
  upsert: DaysUpsertNestedInput
  connect: DaysWhereUniqueInput
}

input DaysUpsertNestedInput {
  update: DaysUpdateDataInput!
  create: DaysCreateInput!
}

input DaysWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [DaysWhereInput!]
  OR: [DaysWhereInput!]
  NOT: [DaysWhereInput!]
}

input DaysWhereUniqueInput {
  id: ID
}

type Feature {
  id: ID!
  title: String!
}

type FeatureConnection {
  pageInfo: PageInfo!
  edges: [FeatureEdge]!
  aggregate: AggregateFeature!
}

input FeatureCreateInput {
  id: ID
  title: String!
}

input FeatureCreateManyInput {
  create: [FeatureCreateInput!]
  connect: [FeatureWhereUniqueInput!]
}

type FeatureEdge {
  node: Feature!
  cursor: String!
}

enum FeatureOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type FeaturePreviousValues {
  id: ID!
  title: String!
}

input FeatureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [FeatureScalarWhereInput!]
  OR: [FeatureScalarWhereInput!]
  NOT: [FeatureScalarWhereInput!]
}

type FeatureSubscriptionPayload {
  mutation: MutationType!
  node: Feature
  updatedFields: [String!]
  previousValues: FeaturePreviousValues
}

input FeatureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeatureWhereInput
  AND: [FeatureSubscriptionWhereInput!]
  OR: [FeatureSubscriptionWhereInput!]
  NOT: [FeatureSubscriptionWhereInput!]
}

input FeatureUpdateDataInput {
  title: String
}

input FeatureUpdateInput {
  title: String
}

input FeatureUpdateManyDataInput {
  title: String
}

input FeatureUpdateManyInput {
  create: [FeatureCreateInput!]
  update: [FeatureUpdateWithWhereUniqueNestedInput!]
  upsert: [FeatureUpsertWithWhereUniqueNestedInput!]
  delete: [FeatureWhereUniqueInput!]
  connect: [FeatureWhereUniqueInput!]
  set: [FeatureWhereUniqueInput!]
  disconnect: [FeatureWhereUniqueInput!]
  deleteMany: [FeatureScalarWhereInput!]
  updateMany: [FeatureUpdateManyWithWhereNestedInput!]
}

input FeatureUpdateManyMutationInput {
  title: String
}

input FeatureUpdateManyWithWhereNestedInput {
  where: FeatureScalarWhereInput!
  data: FeatureUpdateManyDataInput!
}

input FeatureUpdateWithWhereUniqueNestedInput {
  where: FeatureWhereUniqueInput!
  data: FeatureUpdateDataInput!
}

input FeatureUpsertWithWhereUniqueNestedInput {
  where: FeatureWhereUniqueInput!
  update: FeatureUpdateDataInput!
  create: FeatureCreateInput!
}

input FeatureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [FeatureWhereInput!]
  OR: [FeatureWhereInput!]
  NOT: [FeatureWhereInput!]
}

input FeatureWhereUniqueInput {
  id: ID
}

type Geometry {
  id: ID!
  location: Location!
  viewport: Viewport!
}

type GeometryConnection {
  pageInfo: PageInfo!
  edges: [GeometryEdge]!
  aggregate: AggregateGeometry!
}

input GeometryCreateInput {
  id: ID
  location: LocationCreateOneInput!
  viewport: ViewportCreateOneInput!
}

input GeometryCreateOneInput {
  create: GeometryCreateInput
  connect: GeometryWhereUniqueInput
}

type GeometryEdge {
  node: Geometry!
  cursor: String!
}

enum GeometryOrderByInput {
  id_ASC
  id_DESC
}

type GeometryPreviousValues {
  id: ID!
}

type GeometrySubscriptionPayload {
  mutation: MutationType!
  node: Geometry
  updatedFields: [String!]
  previousValues: GeometryPreviousValues
}

input GeometrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GeometryWhereInput
  AND: [GeometrySubscriptionWhereInput!]
  OR: [GeometrySubscriptionWhereInput!]
  NOT: [GeometrySubscriptionWhereInput!]
}

input GeometryUpdateDataInput {
  location: LocationUpdateOneRequiredInput
  viewport: ViewportUpdateOneRequiredInput
}

input GeometryUpdateInput {
  location: LocationUpdateOneRequiredInput
  viewport: ViewportUpdateOneRequiredInput
}

input GeometryUpdateOneRequiredInput {
  create: GeometryCreateInput
  update: GeometryUpdateDataInput
  upsert: GeometryUpsertNestedInput
  connect: GeometryWhereUniqueInput
}

input GeometryUpsertNestedInput {
  update: GeometryUpdateDataInput!
  create: GeometryCreateInput!
}

input GeometryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  location: LocationWhereInput
  viewport: ViewportWhereInput
  AND: [GeometryWhereInput!]
  OR: [GeometryWhereInput!]
  NOT: [GeometryWhereInput!]
}

input GeometryWhereUniqueInput {
  id: ID
}

type GeoPoint {
  id: ID!
  boundary: Json!
}

type GeoPointConnection {
  pageInfo: PageInfo!
  edges: [GeoPointEdge]!
  aggregate: AggregateGeoPoint!
}

input GeoPointCreateInput {
  id: ID
  boundary: Json!
}

input GeoPointCreateManyInput {
  create: [GeoPointCreateInput!]
  connect: [GeoPointWhereUniqueInput!]
}

type GeoPointEdge {
  node: GeoPoint!
  cursor: String!
}

enum GeoPointOrderByInput {
  id_ASC
  id_DESC
  boundary_ASC
  boundary_DESC
}

type GeoPointPreviousValues {
  id: ID!
  boundary: Json!
}

input GeoPointScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GeoPointScalarWhereInput!]
  OR: [GeoPointScalarWhereInput!]
  NOT: [GeoPointScalarWhereInput!]
}

type GeoPointSubscriptionPayload {
  mutation: MutationType!
  node: GeoPoint
  updatedFields: [String!]
  previousValues: GeoPointPreviousValues
}

input GeoPointSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GeoPointWhereInput
  AND: [GeoPointSubscriptionWhereInput!]
  OR: [GeoPointSubscriptionWhereInput!]
  NOT: [GeoPointSubscriptionWhereInput!]
}

input GeoPointUpdateDataInput {
  boundary: Json
}

input GeoPointUpdateInput {
  boundary: Json
}

input GeoPointUpdateManyDataInput {
  boundary: Json
}

input GeoPointUpdateManyInput {
  create: [GeoPointCreateInput!]
  update: [GeoPointUpdateWithWhereUniqueNestedInput!]
  upsert: [GeoPointUpsertWithWhereUniqueNestedInput!]
  delete: [GeoPointWhereUniqueInput!]
  connect: [GeoPointWhereUniqueInput!]
  set: [GeoPointWhereUniqueInput!]
  disconnect: [GeoPointWhereUniqueInput!]
  deleteMany: [GeoPointScalarWhereInput!]
  updateMany: [GeoPointUpdateManyWithWhereNestedInput!]
}

input GeoPointUpdateManyMutationInput {
  boundary: Json
}

input GeoPointUpdateManyWithWhereNestedInput {
  where: GeoPointScalarWhereInput!
  data: GeoPointUpdateManyDataInput!
}

input GeoPointUpdateWithWhereUniqueNestedInput {
  where: GeoPointWhereUniqueInput!
  data: GeoPointUpdateDataInput!
}

input GeoPointUpsertWithWhereUniqueNestedInput {
  where: GeoPointWhereUniqueInput!
  update: GeoPointUpdateDataInput!
  create: GeoPointCreateInput!
}

input GeoPointWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GeoPointWhereInput!]
  OR: [GeoPointWhereInput!]
  NOT: [GeoPointWhereInput!]
}

input GeoPointWhereUniqueInput {
  id: ID
}

type Goal {
  id: ID!
  hours: Float!
  days: Days!
}

type GoalConnection {
  pageInfo: PageInfo!
  edges: [GoalEdge]!
  aggregate: AggregateGoal!
}

input GoalCreateInput {
  id: ID
  hours: Float!
  days: DaysCreateOneInput!
}

type GoalEdge {
  node: Goal!
  cursor: String!
}

enum GoalOrderByInput {
  id_ASC
  id_DESC
  hours_ASC
  hours_DESC
}

type GoalPreviousValues {
  id: ID!
  hours: Float!
}

type GoalSubscriptionPayload {
  mutation: MutationType!
  node: Goal
  updatedFields: [String!]
  previousValues: GoalPreviousValues
}

input GoalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GoalWhereInput
  AND: [GoalSubscriptionWhereInput!]
  OR: [GoalSubscriptionWhereInput!]
  NOT: [GoalSubscriptionWhereInput!]
}

input GoalUpdateInput {
  hours: Float
  days: DaysUpdateOneRequiredInput
}

input GoalUpdateManyMutationInput {
  hours: Float
}

input GoalWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hours: Float
  hours_not: Float
  hours_in: [Float!]
  hours_not_in: [Float!]
  hours_lt: Float
  hours_lte: Float
  hours_gt: Float
  hours_gte: Float
  days: DaysWhereInput
  AND: [GoalWhereInput!]
  OR: [GoalWhereInput!]
  NOT: [GoalWhereInput!]
}

input GoalWhereUniqueInput {
  id: ID
}

scalar Json

type Location {
  id: ID!
  lat: Float!
  lng: Float!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  lat: Float!
  lng: Float!
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
}

type LocationPreviousValues {
  id: ID!
  lat: Float!
  lng: Float!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  lat: Float
  lng: Float
}

input LocationUpdateInput {
  lat: Float
  lng: Float
}

input LocationUpdateManyMutationInput {
  lat: Float
  lng: Float
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Map {
  id: ID!
  externalId: String!
  name: String!
  geometry: Geometry!
  vicinity: String!
  plus_code: PlusCode
  photo_reference: String
  opening_hours: Boolean
  features(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feature!]
  boundaries(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GeoPoint!]
}

type MapConnection {
  pageInfo: PageInfo!
  edges: [MapEdge]!
  aggregate: AggregateMap!
}

input MapCreateInput {
  id: ID
  externalId: String!
  name: String!
  geometry: GeometryCreateOneInput!
  vicinity: String!
  plus_code: PlusCodeCreateOneInput
  photo_reference: String
  opening_hours: Boolean
  features: FeatureCreateManyInput
  boundaries: GeoPointCreateManyInput
}

input MapCreateManyInput {
  create: [MapCreateInput!]
  connect: [MapWhereUniqueInput!]
}

type MapEdge {
  node: Map!
  cursor: String!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  externalId_ASC
  externalId_DESC
  name_ASC
  name_DESC
  vicinity_ASC
  vicinity_DESC
  photo_reference_ASC
  photo_reference_DESC
  opening_hours_ASC
  opening_hours_DESC
}

type MapPreviousValues {
  id: ID!
  externalId: String!
  name: String!
  vicinity: String!
  photo_reference: String
  opening_hours: Boolean
}

input MapScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  externalId: String
  externalId_not: String
  externalId_in: [String!]
  externalId_not_in: [String!]
  externalId_lt: String
  externalId_lte: String
  externalId_gt: String
  externalId_gte: String
  externalId_contains: String
  externalId_not_contains: String
  externalId_starts_with: String
  externalId_not_starts_with: String
  externalId_ends_with: String
  externalId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vicinity: String
  vicinity_not: String
  vicinity_in: [String!]
  vicinity_not_in: [String!]
  vicinity_lt: String
  vicinity_lte: String
  vicinity_gt: String
  vicinity_gte: String
  vicinity_contains: String
  vicinity_not_contains: String
  vicinity_starts_with: String
  vicinity_not_starts_with: String
  vicinity_ends_with: String
  vicinity_not_ends_with: String
  photo_reference: String
  photo_reference_not: String
  photo_reference_in: [String!]
  photo_reference_not_in: [String!]
  photo_reference_lt: String
  photo_reference_lte: String
  photo_reference_gt: String
  photo_reference_gte: String
  photo_reference_contains: String
  photo_reference_not_contains: String
  photo_reference_starts_with: String
  photo_reference_not_starts_with: String
  photo_reference_ends_with: String
  photo_reference_not_ends_with: String
  opening_hours: Boolean
  opening_hours_not: Boolean
  AND: [MapScalarWhereInput!]
  OR: [MapScalarWhereInput!]
  NOT: [MapScalarWhereInput!]
}

type MapSubscriptionPayload {
  mutation: MutationType!
  node: Map
  updatedFields: [String!]
  previousValues: MapPreviousValues
}

input MapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MapWhereInput
  AND: [MapSubscriptionWhereInput!]
  OR: [MapSubscriptionWhereInput!]
  NOT: [MapSubscriptionWhereInput!]
}

input MapUpdateDataInput {
  externalId: String
  name: String
  geometry: GeometryUpdateOneRequiredInput
  vicinity: String
  plus_code: PlusCodeUpdateOneInput
  photo_reference: String
  opening_hours: Boolean
  features: FeatureUpdateManyInput
  boundaries: GeoPointUpdateManyInput
}

input MapUpdateInput {
  externalId: String
  name: String
  geometry: GeometryUpdateOneRequiredInput
  vicinity: String
  plus_code: PlusCodeUpdateOneInput
  photo_reference: String
  opening_hours: Boolean
  features: FeatureUpdateManyInput
  boundaries: GeoPointUpdateManyInput
}

input MapUpdateManyDataInput {
  externalId: String
  name: String
  vicinity: String
  photo_reference: String
  opening_hours: Boolean
}

input MapUpdateManyInput {
  create: [MapCreateInput!]
  update: [MapUpdateWithWhereUniqueNestedInput!]
  upsert: [MapUpsertWithWhereUniqueNestedInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyMutationInput {
  externalId: String
  name: String
  vicinity: String
  photo_reference: String
  opening_hours: Boolean
}

input MapUpdateManyWithWhereNestedInput {
  where: MapScalarWhereInput!
  data: MapUpdateManyDataInput!
}

input MapUpdateWithWhereUniqueNestedInput {
  where: MapWhereUniqueInput!
  data: MapUpdateDataInput!
}

input MapUpsertWithWhereUniqueNestedInput {
  where: MapWhereUniqueInput!
  update: MapUpdateDataInput!
  create: MapCreateInput!
}

input MapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  externalId: String
  externalId_not: String
  externalId_in: [String!]
  externalId_not_in: [String!]
  externalId_lt: String
  externalId_lte: String
  externalId_gt: String
  externalId_gte: String
  externalId_contains: String
  externalId_not_contains: String
  externalId_starts_with: String
  externalId_not_starts_with: String
  externalId_ends_with: String
  externalId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  geometry: GeometryWhereInput
  vicinity: String
  vicinity_not: String
  vicinity_in: [String!]
  vicinity_not_in: [String!]
  vicinity_lt: String
  vicinity_lte: String
  vicinity_gt: String
  vicinity_gte: String
  vicinity_contains: String
  vicinity_not_contains: String
  vicinity_starts_with: String
  vicinity_not_starts_with: String
  vicinity_ends_with: String
  vicinity_not_ends_with: String
  plus_code: PlusCodeWhereInput
  photo_reference: String
  photo_reference_not: String
  photo_reference_in: [String!]
  photo_reference_not_in: [String!]
  photo_reference_lt: String
  photo_reference_lte: String
  photo_reference_gt: String
  photo_reference_gte: String
  photo_reference_contains: String
  photo_reference_not_contains: String
  photo_reference_starts_with: String
  photo_reference_not_starts_with: String
  photo_reference_ends_with: String
  photo_reference_not_ends_with: String
  opening_hours: Boolean
  opening_hours_not: Boolean
  features_every: FeatureWhereInput
  features_some: FeatureWhereInput
  features_none: FeatureWhereInput
  boundaries_every: GeoPointWhereInput
  boundaries_some: GeoPointWhereInput
  boundaries_none: GeoPointWhereInput
  AND: [MapWhereInput!]
  OR: [MapWhereInput!]
  NOT: [MapWhereInput!]
}

input MapWhereUniqueInput {
  id: ID
}

type Mutation {
  createDays(data: DaysCreateInput!): Days!
  updateDays(data: DaysUpdateInput!, where: DaysWhereUniqueInput!): Days
  updateManyDayses(data: DaysUpdateManyMutationInput!, where: DaysWhereInput): BatchPayload!
  upsertDays(where: DaysWhereUniqueInput!, create: DaysCreateInput!, update: DaysUpdateInput!): Days!
  deleteDays(where: DaysWhereUniqueInput!): Days
  deleteManyDayses(where: DaysWhereInput): BatchPayload!
  createFeature(data: FeatureCreateInput!): Feature!
  updateFeature(data: FeatureUpdateInput!, where: FeatureWhereUniqueInput!): Feature
  updateManyFeatures(data: FeatureUpdateManyMutationInput!, where: FeatureWhereInput): BatchPayload!
  upsertFeature(where: FeatureWhereUniqueInput!, create: FeatureCreateInput!, update: FeatureUpdateInput!): Feature!
  deleteFeature(where: FeatureWhereUniqueInput!): Feature
  deleteManyFeatures(where: FeatureWhereInput): BatchPayload!
  createGeoPoint(data: GeoPointCreateInput!): GeoPoint!
  updateGeoPoint(data: GeoPointUpdateInput!, where: GeoPointWhereUniqueInput!): GeoPoint
  updateManyGeoPoints(data: GeoPointUpdateManyMutationInput!, where: GeoPointWhereInput): BatchPayload!
  upsertGeoPoint(where: GeoPointWhereUniqueInput!, create: GeoPointCreateInput!, update: GeoPointUpdateInput!): GeoPoint!
  deleteGeoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  deleteManyGeoPoints(where: GeoPointWhereInput): BatchPayload!
  createGeometry(data: GeometryCreateInput!): Geometry!
  updateGeometry(data: GeometryUpdateInput!, where: GeometryWhereUniqueInput!): Geometry
  upsertGeometry(where: GeometryWhereUniqueInput!, create: GeometryCreateInput!, update: GeometryUpdateInput!): Geometry!
  deleteGeometry(where: GeometryWhereUniqueInput!): Geometry
  deleteManyGeometries(where: GeometryWhereInput): BatchPayload!
  createGoal(data: GoalCreateInput!): Goal!
  updateGoal(data: GoalUpdateInput!, where: GoalWhereUniqueInput!): Goal
  updateManyGoals(data: GoalUpdateManyMutationInput!, where: GoalWhereInput): BatchPayload!
  upsertGoal(where: GoalWhereUniqueInput!, create: GoalCreateInput!, update: GoalUpdateInput!): Goal!
  deleteGoal(where: GoalWhereUniqueInput!): Goal
  deleteManyGoals(where: GoalWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMap(data: MapCreateInput!): Map!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  upsertMap(where: MapWhereUniqueInput!, create: MapCreateInput!, update: MapUpdateInput!): Map!
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  createNorthEast(data: NorthEastCreateInput!): NorthEast!
  updateNorthEast(data: NorthEastUpdateInput!, where: NorthEastWhereUniqueInput!): NorthEast
  updateManyNorthEasts(data: NorthEastUpdateManyMutationInput!, where: NorthEastWhereInput): BatchPayload!
  upsertNorthEast(where: NorthEastWhereUniqueInput!, create: NorthEastCreateInput!, update: NorthEastUpdateInput!): NorthEast!
  deleteNorthEast(where: NorthEastWhereUniqueInput!): NorthEast
  deleteManyNorthEasts(where: NorthEastWhereInput): BatchPayload!
  createPlusCode(data: PlusCodeCreateInput!): PlusCode!
  updatePlusCode(data: PlusCodeUpdateInput!, where: PlusCodeWhereUniqueInput!): PlusCode
  updateManyPlusCodes(data: PlusCodeUpdateManyMutationInput!, where: PlusCodeWhereInput): BatchPayload!
  upsertPlusCode(where: PlusCodeWhereUniqueInput!, create: PlusCodeCreateInput!, update: PlusCodeUpdateInput!): PlusCode!
  deletePlusCode(where: PlusCodeWhereUniqueInput!): PlusCode
  deleteManyPlusCodes(where: PlusCodeWhereInput): BatchPayload!
  createProgress(data: ProgressCreateInput!): Progress!
  updateProgress(data: ProgressUpdateInput!, where: ProgressWhereUniqueInput!): Progress
  updateManyProgresses(data: ProgressUpdateManyMutationInput!, where: ProgressWhereInput): BatchPayload!
  upsertProgress(where: ProgressWhereUniqueInput!, create: ProgressCreateInput!, update: ProgressUpdateInput!): Progress!
  deleteProgress(where: ProgressWhereUniqueInput!): Progress
  deleteManyProgresses(where: ProgressWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createSouthWest(data: SouthWestCreateInput!): SouthWest!
  updateSouthWest(data: SouthWestUpdateInput!, where: SouthWestWhereUniqueInput!): SouthWest
  updateManySouthWests(data: SouthWestUpdateManyMutationInput!, where: SouthWestWhereInput): BatchPayload!
  upsertSouthWest(where: SouthWestWhereUniqueInput!, create: SouthWestCreateInput!, update: SouthWestUpdateInput!): SouthWest!
  deleteSouthWest(where: SouthWestWhereUniqueInput!): SouthWest
  deleteManySouthWests(where: SouthWestWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createViewport(data: ViewportCreateInput!): Viewport!
  updateViewport(data: ViewportUpdateInput!, where: ViewportWhereUniqueInput!): Viewport
  upsertViewport(where: ViewportWhereUniqueInput!, create: ViewportCreateInput!, update: ViewportUpdateInput!): Viewport!
  deleteViewport(where: ViewportWhereUniqueInput!): Viewport
  deleteManyViewports(where: ViewportWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type NorthEast {
  id: ID!
  lat: Float!
  lng: Float!
}

type NorthEastConnection {
  pageInfo: PageInfo!
  edges: [NorthEastEdge]!
  aggregate: AggregateNorthEast!
}

input NorthEastCreateInput {
  id: ID
  lat: Float!
  lng: Float!
}

input NorthEastCreateOneInput {
  create: NorthEastCreateInput
  connect: NorthEastWhereUniqueInput
}

type NorthEastEdge {
  node: NorthEast!
  cursor: String!
}

enum NorthEastOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
}

type NorthEastPreviousValues {
  id: ID!
  lat: Float!
  lng: Float!
}

type NorthEastSubscriptionPayload {
  mutation: MutationType!
  node: NorthEast
  updatedFields: [String!]
  previousValues: NorthEastPreviousValues
}

input NorthEastSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NorthEastWhereInput
  AND: [NorthEastSubscriptionWhereInput!]
  OR: [NorthEastSubscriptionWhereInput!]
  NOT: [NorthEastSubscriptionWhereInput!]
}

input NorthEastUpdateDataInput {
  lat: Float
  lng: Float
}

input NorthEastUpdateInput {
  lat: Float
  lng: Float
}

input NorthEastUpdateManyMutationInput {
  lat: Float
  lng: Float
}

input NorthEastUpdateOneRequiredInput {
  create: NorthEastCreateInput
  update: NorthEastUpdateDataInput
  upsert: NorthEastUpsertNestedInput
  connect: NorthEastWhereUniqueInput
}

input NorthEastUpsertNestedInput {
  update: NorthEastUpdateDataInput!
  create: NorthEastCreateInput!
}

input NorthEastWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  AND: [NorthEastWhereInput!]
  OR: [NorthEastWhereInput!]
  NOT: [NorthEastWhereInput!]
}

input NorthEastWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PlusCode {
  id: ID!
  compound_code: String
  global_code: String
}

type PlusCodeConnection {
  pageInfo: PageInfo!
  edges: [PlusCodeEdge]!
  aggregate: AggregatePlusCode!
}

input PlusCodeCreateInput {
  id: ID
  compound_code: String
  global_code: String
}

input PlusCodeCreateOneInput {
  create: PlusCodeCreateInput
  connect: PlusCodeWhereUniqueInput
}

type PlusCodeEdge {
  node: PlusCode!
  cursor: String!
}

enum PlusCodeOrderByInput {
  id_ASC
  id_DESC
  compound_code_ASC
  compound_code_DESC
  global_code_ASC
  global_code_DESC
}

type PlusCodePreviousValues {
  id: ID!
  compound_code: String
  global_code: String
}

type PlusCodeSubscriptionPayload {
  mutation: MutationType!
  node: PlusCode
  updatedFields: [String!]
  previousValues: PlusCodePreviousValues
}

input PlusCodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlusCodeWhereInput
  AND: [PlusCodeSubscriptionWhereInput!]
  OR: [PlusCodeSubscriptionWhereInput!]
  NOT: [PlusCodeSubscriptionWhereInput!]
}

input PlusCodeUpdateDataInput {
  compound_code: String
  global_code: String
}

input PlusCodeUpdateInput {
  compound_code: String
  global_code: String
}

input PlusCodeUpdateManyMutationInput {
  compound_code: String
  global_code: String
}

input PlusCodeUpdateOneInput {
  create: PlusCodeCreateInput
  update: PlusCodeUpdateDataInput
  upsert: PlusCodeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PlusCodeWhereUniqueInput
}

input PlusCodeUpsertNestedInput {
  update: PlusCodeUpdateDataInput!
  create: PlusCodeCreateInput!
}

input PlusCodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  compound_code: String
  compound_code_not: String
  compound_code_in: [String!]
  compound_code_not_in: [String!]
  compound_code_lt: String
  compound_code_lte: String
  compound_code_gt: String
  compound_code_gte: String
  compound_code_contains: String
  compound_code_not_contains: String
  compound_code_starts_with: String
  compound_code_not_starts_with: String
  compound_code_ends_with: String
  compound_code_not_ends_with: String
  global_code: String
  global_code_not: String
  global_code_in: [String!]
  global_code_not_in: [String!]
  global_code_lt: String
  global_code_lte: String
  global_code_gt: String
  global_code_gte: String
  global_code_contains: String
  global_code_not_contains: String
  global_code_starts_with: String
  global_code_not_starts_with: String
  global_code_ends_with: String
  global_code_not_ends_with: String
  AND: [PlusCodeWhereInput!]
  OR: [PlusCodeWhereInput!]
  NOT: [PlusCodeWhereInput!]
}

input PlusCodeWhereUniqueInput {
  id: ID
}

type Progress {
  id: ID!
  duration: Float!
  completion: Float!
  date: DateTime!
  weekday: String!
}

type ProgressConnection {
  pageInfo: PageInfo!
  edges: [ProgressEdge]!
  aggregate: AggregateProgress!
}

input ProgressCreateInput {
  id: ID
  duration: Float!
  completion: Float!
  date: DateTime!
  weekday: String!
}

type ProgressEdge {
  node: Progress!
  cursor: String!
}

enum ProgressOrderByInput {
  id_ASC
  id_DESC
  duration_ASC
  duration_DESC
  completion_ASC
  completion_DESC
  date_ASC
  date_DESC
  weekday_ASC
  weekday_DESC
}

type ProgressPreviousValues {
  id: ID!
  duration: Float!
  completion: Float!
  date: DateTime!
  weekday: String!
}

type ProgressSubscriptionPayload {
  mutation: MutationType!
  node: Progress
  updatedFields: [String!]
  previousValues: ProgressPreviousValues
}

input ProgressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProgressWhereInput
  AND: [ProgressSubscriptionWhereInput!]
  OR: [ProgressSubscriptionWhereInput!]
  NOT: [ProgressSubscriptionWhereInput!]
}

input ProgressUpdateInput {
  duration: Float
  completion: Float
  date: DateTime
  weekday: String
}

input ProgressUpdateManyMutationInput {
  duration: Float
  completion: Float
  date: DateTime
  weekday: String
}

input ProgressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  duration: Float
  duration_not: Float
  duration_in: [Float!]
  duration_not_in: [Float!]
  duration_lt: Float
  duration_lte: Float
  duration_gt: Float
  duration_gte: Float
  completion: Float
  completion_not: Float
  completion_in: [Float!]
  completion_not_in: [Float!]
  completion_lt: Float
  completion_lte: Float
  completion_gt: Float
  completion_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  weekday: String
  weekday_not: String
  weekday_in: [String!]
  weekday_not_in: [String!]
  weekday_lt: String
  weekday_lte: String
  weekday_gt: String
  weekday_gte: String
  weekday_contains: String
  weekday_not_contains: String
  weekday_starts_with: String
  weekday_not_starts_with: String
  weekday_ends_with: String
  weekday_not_ends_with: String
  AND: [ProgressWhereInput!]
  OR: [ProgressWhereInput!]
  NOT: [ProgressWhereInput!]
}

input ProgressWhereUniqueInput {
  id: ID
}

type Query {
  days(where: DaysWhereUniqueInput!): Days
  dayses(where: DaysWhereInput, orderBy: DaysOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Days]!
  daysesConnection(where: DaysWhereInput, orderBy: DaysOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DaysConnection!
  feature(where: FeatureWhereUniqueInput!): Feature
  features(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feature]!
  featuresConnection(where: FeatureWhereInput, orderBy: FeatureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeatureConnection!
  geoPoint(where: GeoPointWhereUniqueInput!): GeoPoint
  geoPoints(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GeoPoint]!
  geoPointsConnection(where: GeoPointWhereInput, orderBy: GeoPointOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GeoPointConnection!
  geometry(where: GeometryWhereUniqueInput!): Geometry
  geometries(where: GeometryWhereInput, orderBy: GeometryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Geometry]!
  geometriesConnection(where: GeometryWhereInput, orderBy: GeometryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GeometryConnection!
  goal(where: GoalWhereUniqueInput!): Goal
  goals(where: GoalWhereInput, orderBy: GoalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Goal]!
  goalsConnection(where: GoalWhereInput, orderBy: GoalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GoalConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map]!
  mapsConnection(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MapConnection!
  northEast(where: NorthEastWhereUniqueInput!): NorthEast
  northEasts(where: NorthEastWhereInput, orderBy: NorthEastOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NorthEast]!
  northEastsConnection(where: NorthEastWhereInput, orderBy: NorthEastOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NorthEastConnection!
  plusCode(where: PlusCodeWhereUniqueInput!): PlusCode
  plusCodes(where: PlusCodeWhereInput, orderBy: PlusCodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlusCode]!
  plusCodesConnection(where: PlusCodeWhereInput, orderBy: PlusCodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlusCodeConnection!
  progress(where: ProgressWhereUniqueInput!): Progress
  progresses(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progress]!
  progressesConnection(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProgressConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  southWest(where: SouthWestWhereUniqueInput!): SouthWest
  southWests(where: SouthWestWhereInput, orderBy: SouthWestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SouthWest]!
  southWestsConnection(where: SouthWestWhereInput, orderBy: SouthWestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SouthWestConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  viewport(where: ViewportWhereUniqueInput!): Viewport
  viewports(where: ViewportWhereInput, orderBy: ViewportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Viewport]!
  viewportsConnection(where: ViewportWhereInput, orderBy: ViewportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ViewportConnection!
  node(id: ID!): Node
}

type Session {
  id: ID!
  timeStart: DateTime!
  timeEnd: DateTime!
  locations(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  mood: Float
  journal: String
  date: DateTime!
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  timeStart: DateTime!
  timeEnd: DateTime!
  locations: MapCreateManyInput
  mood: Float
  journal: String
  date: DateTime!
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  timeStart_ASC
  timeStart_DESC
  timeEnd_ASC
  timeEnd_DESC
  mood_ASC
  mood_DESC
  journal_ASC
  journal_DESC
  date_ASC
  date_DESC
}

type SessionPreviousValues {
  id: ID!
  timeStart: DateTime!
  timeEnd: DateTime!
  mood: Float
  journal: String
  date: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  timeStart: DateTime
  timeEnd: DateTime
  locations: MapUpdateManyInput
  mood: Float
  journal: String
  date: DateTime
}

input SessionUpdateManyMutationInput {
  timeStart: DateTime
  timeEnd: DateTime
  mood: Float
  journal: String
  date: DateTime
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  timeStart: DateTime
  timeStart_not: DateTime
  timeStart_in: [DateTime!]
  timeStart_not_in: [DateTime!]
  timeStart_lt: DateTime
  timeStart_lte: DateTime
  timeStart_gt: DateTime
  timeStart_gte: DateTime
  timeEnd: DateTime
  timeEnd_not: DateTime
  timeEnd_in: [DateTime!]
  timeEnd_not_in: [DateTime!]
  timeEnd_lt: DateTime
  timeEnd_lte: DateTime
  timeEnd_gt: DateTime
  timeEnd_gte: DateTime
  locations_every: MapWhereInput
  locations_some: MapWhereInput
  locations_none: MapWhereInput
  mood: Float
  mood_not: Float
  mood_in: [Float!]
  mood_not_in: [Float!]
  mood_lt: Float
  mood_lte: Float
  mood_gt: Float
  mood_gte: Float
  journal: String
  journal_not: String
  journal_in: [String!]
  journal_not_in: [String!]
  journal_lt: String
  journal_lte: String
  journal_gt: String
  journal_gte: String
  journal_contains: String
  journal_not_contains: String
  journal_starts_with: String
  journal_not_starts_with: String
  journal_ends_with: String
  journal_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type SouthWest {
  id: ID!
  lat: Float!
  lng: Float!
}

type SouthWestConnection {
  pageInfo: PageInfo!
  edges: [SouthWestEdge]!
  aggregate: AggregateSouthWest!
}

input SouthWestCreateInput {
  id: ID
  lat: Float!
  lng: Float!
}

input SouthWestCreateOneInput {
  create: SouthWestCreateInput
  connect: SouthWestWhereUniqueInput
}

type SouthWestEdge {
  node: SouthWest!
  cursor: String!
}

enum SouthWestOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
}

type SouthWestPreviousValues {
  id: ID!
  lat: Float!
  lng: Float!
}

type SouthWestSubscriptionPayload {
  mutation: MutationType!
  node: SouthWest
  updatedFields: [String!]
  previousValues: SouthWestPreviousValues
}

input SouthWestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SouthWestWhereInput
  AND: [SouthWestSubscriptionWhereInput!]
  OR: [SouthWestSubscriptionWhereInput!]
  NOT: [SouthWestSubscriptionWhereInput!]
}

input SouthWestUpdateDataInput {
  lat: Float
  lng: Float
}

input SouthWestUpdateInput {
  lat: Float
  lng: Float
}

input SouthWestUpdateManyMutationInput {
  lat: Float
  lng: Float
}

input SouthWestUpdateOneRequiredInput {
  create: SouthWestCreateInput
  update: SouthWestUpdateDataInput
  upsert: SouthWestUpsertNestedInput
  connect: SouthWestWhereUniqueInput
}

input SouthWestUpsertNestedInput {
  update: SouthWestUpdateDataInput!
  create: SouthWestCreateInput!
}

input SouthWestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  AND: [SouthWestWhereInput!]
  OR: [SouthWestWhereInput!]
  NOT: [SouthWestWhereInput!]
}

input SouthWestWhereUniqueInput {
  id: ID
}

type Subscription {
  days(where: DaysSubscriptionWhereInput): DaysSubscriptionPayload
  feature(where: FeatureSubscriptionWhereInput): FeatureSubscriptionPayload
  geoPoint(where: GeoPointSubscriptionWhereInput): GeoPointSubscriptionPayload
  geometry(where: GeometrySubscriptionWhereInput): GeometrySubscriptionPayload
  goal(where: GoalSubscriptionWhereInput): GoalSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  map(where: MapSubscriptionWhereInput): MapSubscriptionPayload
  northEast(where: NorthEastSubscriptionWhereInput): NorthEastSubscriptionPayload
  plusCode(where: PlusCodeSubscriptionWhereInput): PlusCodeSubscriptionPayload
  progress(where: ProgressSubscriptionWhereInput): ProgressSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  southWest(where: SouthWestSubscriptionWhereInput): SouthWestSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  viewport(where: ViewportSubscriptionWhereInput): ViewportSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  password: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type Viewport {
  id: ID!
  northeast: NorthEast!
  southwest: SouthWest!
}

type ViewportConnection {
  pageInfo: PageInfo!
  edges: [ViewportEdge]!
  aggregate: AggregateViewport!
}

input ViewportCreateInput {
  id: ID
  northeast: NorthEastCreateOneInput!
  southwest: SouthWestCreateOneInput!
}

input ViewportCreateOneInput {
  create: ViewportCreateInput
  connect: ViewportWhereUniqueInput
}

type ViewportEdge {
  node: Viewport!
  cursor: String!
}

enum ViewportOrderByInput {
  id_ASC
  id_DESC
}

type ViewportPreviousValues {
  id: ID!
}

type ViewportSubscriptionPayload {
  mutation: MutationType!
  node: Viewport
  updatedFields: [String!]
  previousValues: ViewportPreviousValues
}

input ViewportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ViewportWhereInput
  AND: [ViewportSubscriptionWhereInput!]
  OR: [ViewportSubscriptionWhereInput!]
  NOT: [ViewportSubscriptionWhereInput!]
}

input ViewportUpdateDataInput {
  northeast: NorthEastUpdateOneRequiredInput
  southwest: SouthWestUpdateOneRequiredInput
}

input ViewportUpdateInput {
  northeast: NorthEastUpdateOneRequiredInput
  southwest: SouthWestUpdateOneRequiredInput
}

input ViewportUpdateOneRequiredInput {
  create: ViewportCreateInput
  update: ViewportUpdateDataInput
  upsert: ViewportUpsertNestedInput
  connect: ViewportWhereUniqueInput
}

input ViewportUpsertNestedInput {
  update: ViewportUpdateDataInput!
  create: ViewportCreateInput!
}

input ViewportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  northeast: NorthEastWhereInput
  southwest: SouthWestWhereInput
  AND: [ViewportWhereInput!]
  OR: [ViewportWhereInput!]
  NOT: [ViewportWhereInput!]
}

input ViewportWhereUniqueInput {
  id: ID
}
`
      }
    